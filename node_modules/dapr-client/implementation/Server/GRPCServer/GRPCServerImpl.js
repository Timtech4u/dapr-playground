"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const any_pb_1 = require("google-protobuf/google/protobuf/any_pb");
const common_pb_1 = require("../../../proto/dapr/proto/common/v1/common_pb");
const appcallback_pb_1 = require("../../../proto/dapr/proto/runtime/v1/appcallback_pb");
const HttpVerbUtil = __importStar(require("../../../utils/HttpVerb.util"));
const Logger_1 = require("../../../logger/Logger");
const DaprPubSubStatus_enum_1 = __importDefault(require("../../../enum/DaprPubSubStatus.enum"));
const Deserializer_util_1 = require("../../../utils/Deserializer.util");
// https://github.com/badsyntax/grpc-js-typescript/issues/1#issuecomment-705419742
// @ts-ignore
class GRPCServerImpl {
    constructor(server, loggerOptions) {
        this.PUBSUB_DEFAULT_ROUTE_NAME = "default";
        this.PUBSUB_DEFAULT_ROUTE_NAME_DEADLETTER = "deadletter";
        this.server = server;
        this.logger = new Logger_1.Logger("GRPCServer", "GRPCServerImpl", loggerOptions);
        this.handlersInvoke = {};
        this.handlersBindings = {};
        this.pubSubSubscriptions = {};
    }
    createPubSubSubscriptionHandlerKey(pubSubName, topicName) {
        return `${pubSubName.toLowerCase()}|${topicName.toLowerCase()}`;
    }
    createInputBindingHandlerKey(bindingName) {
        return `${bindingName.toLowerCase()}`;
    }
    createOnInvokeHandlerKey(httpMethod, methodName) {
        return `${httpMethod.toLowerCase()}|${methodName.toLowerCase()}`;
    }
    registerOnInvokeHandler(httpMethod, methodName, cb) {
        const handlerKey = this.createOnInvokeHandlerKey(httpMethod, methodName);
        this.handlersInvoke[handlerKey] = cb;
    }
    /**
     * When we subscribe, we subscribe to a topic
     * For this topic we can define "routes" which route to a certain callback depending on the event content
     * Each of these topics are handled by a EventHandler but there can be multiple handlers per pubsubname-topic-route combination
     *
     * We don't create the EventHandlers here but we ensure that the routes are registered and can receive POST events
     * -> we create POST /<route> endpoints for each, but we create them uniquely!
     * -> to ensure uniqueness, we just check if this.pubsubRouteEventHandlers[route] is set
     *
     * @param pubSubName
     * @param topicName
     * @param cb
     * @param options
     */
    registerPubsubSubscription(pubsubName, topic, options = {}) {
        if (this.pubSubSubscriptions[pubsubName] &&
            this.pubSubSubscriptions[pubsubName][topic] &&
            this.pubSubSubscriptions[pubsubName][topic]) {
            throw new Error(`The topic '${topic}' is already being subscribed to on PubSub '${pubsubName}', there can only be one topic registered.`);
        }
        // Create pubsub subscription it if it doesn't exist
        if (!this.pubSubSubscriptions[pubsubName]) {
            this.pubSubSubscriptions[pubsubName] = {};
        }
        // Add the routes and dapr representation to the topic
        if (!this.pubSubSubscriptions[pubsubName][topic]) {
            this.pubSubSubscriptions[pubsubName][topic] = {
                routes: this.generatePubSubSubscriptionTopicRoutes(pubsubName, topic, options),
                dapr: this.generateDaprPubSubSubscription(pubsubName, topic, options),
            };
        }
        this.logger.info(`[Topic = ${topic}] Registered Subscription with routes: ${Object.keys(this.pubSubSubscriptions[pubsubName][topic].routes).join(", ")}`);
    }
    registerPubSubSubscriptionEventHandler(pubsubName, topic, route, cb) {
        route = this.generatePubSubSubscriptionTopicRouteName(route);
        this.pubSubSubscriptions[pubsubName][topic].routes[route !== null && route !== void 0 ? route : this.PUBSUB_DEFAULT_ROUTE_NAME].eventHandlers.push(cb);
    }
    generatePubSubSubscriptionTopicRouteName(route = "default") {
        return (route || this.PUBSUB_DEFAULT_ROUTE_NAME).replace("/", "");
    }
    generatePubSubSubscriptionTopicRoutes(pubsubName, topic, options = {}) {
        var _a;
        const routes = {};
        // options.route == DaprPubSubRouteType
        if (typeof options.route === "object") {
            // Add default
            if (options.route.default) {
                const routeName = this.generatePubSubSubscriptionTopicRouteName(options.route.default);
                routes[routeName] = {
                    eventHandlers: [],
                    path: this.generatePubsubPath(pubsubName, topic, routeName),
                };
            }
            // Add rules
            if (options.route.rules) {
                for (const rule of options.route.rules) {
                    if (!routes[rule.path]) {
                        const routeName = this.generatePubSubSubscriptionTopicRouteName(rule.path);
                        routes[routeName] = {
                            eventHandlers: [],
                            path: this.generatePubsubPath(pubsubName, topic, routeName),
                        };
                    }
                }
            }
        }
        // options.route == String | undefined
        else {
            const routeName = this.generatePubSubSubscriptionTopicRouteName(options === null || options === void 0 ? void 0 : options.route);
            routes[routeName] = {
                eventHandlers: [],
                path: this.generatePubsubPath(pubsubName, topic, routeName),
            };
        }
        // Deadletter Support
        if (options.deadLetterTopic || options.deadLetterCallback) {
            const routeName = this.generatePubSubSubscriptionTopicRouteName((_a = options === null || options === void 0 ? void 0 : options.deadLetterTopic) !== null && _a !== void 0 ? _a : this.PUBSUB_DEFAULT_ROUTE_NAME_DEADLETTER);
            // Initialize the route
            routes[routeName] = {
                eventHandlers: [],
                path: this.generatePubsubPath(pubsubName, topic, routeName),
            };
            // Add a callback if we have one provided
            if (options.deadLetterCallback) {
                routes[routeName].eventHandlers.push(options.deadLetterCallback);
            }
        }
        return routes;
    }
    generateDaprSubscriptionRoute(pubsubName, topic, route = this.PUBSUB_DEFAULT_ROUTE_NAME) {
        return `/${this.generatePubsubPath(pubsubName, topic, route)}`;
    }
    /**
     * Generate a subscription object that will be used in the /dapr/subscribe endpoint
     * this will let dapr know that we have subscriptions and how they map to routes / deadletter
     *
     * Important: we internally translate the provided /example to -> /<pubsubname>-<topic>-example
     *            or if empty to /<pubsubname>-<topic>-default
     *            this is to ensure that HTTP Server endpoints are unique
     *
     * @param pubsubName
     * @param topic
     * @param options
     * @returns
     */
    generateDaprPubSubSubscription(pubsubName, topic, options = {}) {
        var _a, _b, _c;
        // Process metadata
        let metadata;
        if (options.metadata) {
            metadata = {};
            for (const [key, value] of Object.entries(options.metadata)) {
                metadata[key] = JSON.stringify(value);
            }
        }
        // Process the route
        if (!options || !(options === null || options === void 0 ? void 0 : options.route)) {
            return {
                pubsubname: pubsubName,
                topic: topic,
                metadata: metadata,
                route: this.generateDaprSubscriptionRoute(pubsubName, topic),
                deadLetterTopic: options.deadLetterTopic,
                bulkSubscribe: options.bulkSubscribe,
            };
        }
        else if (typeof options.route === "string") {
            return {
                pubsubname: pubsubName,
                topic: topic,
                metadata: metadata,
                route: this.generateDaprSubscriptionRoute(pubsubName, topic, options.route),
                deadLetterTopic: options.deadLetterTopic,
                bulkSubscribe: options.bulkSubscribe,
            };
        }
        else {
            return {
                pubsubname: pubsubName,
                topic: topic,
                metadata: metadata,
                routes: options.route && {
                    default: this.generateDaprSubscriptionRoute(pubsubName, topic, (_a = options.route) === null || _a === void 0 ? void 0 : _a.default),
                    rules: (_c = (_b = options.route) === null || _b === void 0 ? void 0 : _b.rules) === null || _c === void 0 ? void 0 : _c.map((rule) => ({
                        match: rule.match,
                        path: this.generateDaprSubscriptionRoute(pubsubName, topic, rule.path),
                    })),
                },
                deadLetterTopic: options.deadLetterTopic,
                bulkSubscribe: options.bulkSubscribe,
            };
        }
    }
    generateDaprPubSubSubscriptionList() {
        const dapr = [];
        for (const pubsub of Object.keys(this.pubSubSubscriptions)) {
            for (const topic of Object.keys(this.pubSubSubscriptions[pubsub])) {
                dapr.push(this.pubSubSubscriptions[pubsub][topic].dapr);
            }
        }
        return dapr;
    }
    /**
     * We generate a event handler key based on the path or the route
     * If the route is just a string, that is the path
     * Else the path is configured through a rule of DaprPubSubRuleType
     *
     * @param pubsubName
     * @param topic
     * @param route
     * @returns
     */
    generatePubsubPath(pubsubName, topic, route) {
        let routeParsed = "";
        // First parse the route based on if it was a Rule or a String
        if (!route) {
            routeParsed = this.PUBSUB_DEFAULT_ROUTE_NAME;
        }
        else {
            routeParsed = route;
        }
        // Then, process it
        // Remove leading slashes
        if (routeParsed.startsWith("/")) {
            routeParsed = routeParsed.replace("/", ""); // will only remove first occurence
        }
        return `${pubsubName.toLowerCase()}--${topic.toLowerCase()}--${routeParsed}`;
    }
    registerInputBindingHandler(bindingName, cb) {
        const handlerKey = this.createInputBindingHandlerKey(bindingName);
        this.handlersBindings[handlerKey] = cb;
    }
    // '(call: ServerUnaryCall<InvokeRequest, InvokeResponse>, callback: sendUnaryData<InvokeResponse>) => Promise<...>'
    // handleUnaryCall<InvokeRequest, InvokeResponse>'.
    onInvoke(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = call.request.getMethod();
            const query = call.request.getHttpExtension().toObject();
            const methodStr = HttpVerbUtil.convertHttpVerbNumberToString(query.verb);
            const handlersInvokeKey = `${methodStr.toLowerCase()}|${method.toLowerCase()}`;
            if (!this.handlersInvoke[handlersInvokeKey]) {
                this.logger.warn(`${methodStr} /${method} was not handled`);
                return;
            }
            const body = Buffer.from(call.request.getData().getValue()).toString();
            const contentType = call.request.getContentType();
            // Invoke the Method Callback
            // @TODO add call.metadata, it has headers of original HTTP request.
            const invokeResponseData = yield this.handlersInvoke[handlersInvokeKey]({
                body,
                query: query.querystring,
                metadata: {
                    contentType,
                },
            });
            // Generate Response
            const res = new common_pb_1.InvokeResponse();
            res.setContentType("application/json");
            if (invokeResponseData) {
                const msgSerialized = new any_pb_1.Any();
                msgSerialized.setValue(Buffer.from(JSON.stringify(invokeResponseData), "utf-8"));
                res.setData(msgSerialized);
            }
            // @TODO add Error Handleling, for ex if service returned error with status code
            // also maybe we can map GRPC error codes in a enum
            return callback(null, res);
        });
    }
    // @todo: WIP
    onBindingEvent(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = call.request;
            const handlerKey = this.createInputBindingHandlerKey(req.getName());
            if (!this.handlersBindings[handlerKey]) {
                this.logger.warn(`Event for binding: "${handlerKey}" was not handled`);
                return;
            }
            const data = Buffer.from(req.getData()).toString();
            let dataParsed;
            try {
                dataParsed = JSON.parse(data);
            }
            catch (e) {
                dataParsed = data;
            }
            yield this.handlersBindings[handlerKey](dataParsed);
            // @todo: we should add the state store or output binding binding
            // see: https://docs.dapr.io/reference/api/bindings_api/#binding-endpoints
            const res = new appcallback_pb_1.BindingEventResponse();
            return callback(null, res);
        });
    }
    onTopicEvent(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = call.request;
            const pubsubName = req.getPubsubName();
            const topic = req.getTopic();
            // Route is unique to pubsub and topic and has format pubsub--topic--route so we strip it since else we can't find the route
            const route = this.generatePubSubSubscriptionTopicRouteName(req.getPath().replace(`${pubsubName}--${topic}--`, ""));
            if (!this.pubSubSubscriptions[pubsubName] ||
                !this.pubSubSubscriptions[pubsubName][topic] ||
                !this.pubSubSubscriptions[pubsubName][topic].routes[route]) {
                this.logger.warn(`The topic '${topic}' is not being subscribed to on PubSub '${pubsubName}' for route '${route}'.`);
                return;
            }
            const data = (0, Deserializer_util_1.deserializeGrpc)(req.getDataContentType(), req.getData());
            const res = new appcallback_pb_1.TopicEventResponse();
            // Get the headers
            const headers = {};
            for (const [key, value] of Object.entries(call.metadata.toHttp2Headers())) {
                if (value) {
                    headers[key] = value.toString();
                }
            }
            // Process the callbacks
            // we handle priority of status on `RETRY` > `DROP` > `SUCCESS` and default to `SUCCESS`
            const routeObj = this.pubSubSubscriptions[pubsubName][topic].routes[route];
            const status = yield this.processPubSubCallbacks(routeObj, data, headers);
            switch (status) {
                case DaprPubSubStatus_enum_1.default.RETRY:
                    res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.RETRY);
                    break;
                case DaprPubSubStatus_enum_1.default.DROP:
                    res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.DROP);
                    break;
                case DaprPubSubStatus_enum_1.default.SUCCESS:
                default:
                    res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.SUCCESS);
                    break;
            }
            return callback(null, res);
        });
    }
    onBulkTopicEventAlpha1(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = call.request;
            const pubsubName = req.getPubsubName();
            const topic = req.getTopic();
            // Route is unique to pubsub and topic and has format pubsub--topic--route so we strip it since else we can't find the route
            const route = this.generatePubSubSubscriptionTopicRouteName(req.getPath().replace(`${pubsubName}--${topic}--`, ""));
            if (!this.pubSubSubscriptions[pubsubName] ||
                !this.pubSubSubscriptions[pubsubName][topic] ||
                !this.pubSubSubscriptions[pubsubName][topic].routes[route]) {
                this.logger.warn(`The topic '${topic}' is not being subscribed to on PubSub '${pubsubName}' for route '${route}'.`);
                return;
            }
            const resArr = [];
            const entries = req.getEntriesList();
            for (const ind in entries) {
                const event = entries[ind];
                let data;
                if (event.hasBytes()) {
                    data = (0, Deserializer_util_1.deserializeGrpc)(event.getContentType(), event.getBytes());
                }
                else if (event.hasCloudEvent()) {
                    const cloudEvent = event.getCloudEvent();
                    if (cloudEvent instanceof appcallback_pb_1.TopicEventCERequest) {
                        data = (0, Deserializer_util_1.deserializeGrpc)(cloudEvent.getDataContentType(), cloudEvent.getData());
                    }
                }
                const res = new appcallback_pb_1.TopicEventBulkResponseEntry();
                // Get the headers
                const headers = {};
                for (const [key, value] of Object.entries(call.metadata.toHttp2Headers())) {
                    if (value) {
                        headers[key] = value.toString();
                    }
                }
                // Process the callbacks
                // we handle priority of status on `RETRY` > `DROP` > `SUCCESS` and default to `SUCCESS`
                const routeObj = this.pubSubSubscriptions[pubsubName][topic].routes[route];
                const status = yield this.processPubSubCallbacks(routeObj, data, headers);
                switch (status) {
                    case DaprPubSubStatus_enum_1.default.RETRY:
                        res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.RETRY);
                        break;
                    case DaprPubSubStatus_enum_1.default.DROP:
                        res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.DROP);
                        break;
                    case DaprPubSubStatus_enum_1.default.SUCCESS:
                    default:
                        res.setStatus(appcallback_pb_1.TopicEventResponse.TopicEventResponseStatus.SUCCESS);
                        break;
                }
                res.setEntryId(event.getEntryId());
                resArr.push(res);
            }
            const totalRes = new appcallback_pb_1.TopicEventBulkResponse();
            totalRes.setStatusesList(resArr);
            return callback(null, totalRes);
        });
    }
    processPubSubCallbacks(routeObj, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            const eventHandlers = routeObj.eventHandlers;
            const statuses = [];
            // Process the callbacks (default: SUCCESS)
            for (const cb of eventHandlers) {
                let status = DaprPubSubStatus_enum_1.default.SUCCESS;
                try {
                    status = yield cb(data, headers);
                }
                catch (e) {
                    // We catch and log an error, but we don't do anything with it as the statuses should define that
                    this.logger.error(`[route-${routeObj.path}] Message processing failed, ${e}`);
                }
                statuses.push(status !== null && status !== void 0 ? status : DaprPubSubStatus_enum_1.default.SUCCESS);
            }
            // Look at the statuses and return the highest priority
            // we handle priority of status on `RETRY` > `DROP` > `SUCCESS`
            if (statuses.includes(DaprPubSubStatus_enum_1.default.RETRY)) {
                this.logger.debug(`[route-${routeObj.path}] Retrying message`);
                return DaprPubSubStatus_enum_1.default.RETRY;
            }
            else if (statuses.includes(DaprPubSubStatus_enum_1.default.DROP)) {
                this.logger.debug(`[route-${routeObj.path}] Dropping message`);
                return DaprPubSubStatus_enum_1.default.DROP;
            }
            else {
                this.logger.debug(`[route-${routeObj.path}] Acknowledging message`);
                return DaprPubSubStatus_enum_1.default.SUCCESS;
            }
        });
    }
    // Dapr will call this on startup to see which topics it is subscribed to
    listTopicSubscriptions(call, callback) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            const res = new appcallback_pb_1.ListTopicSubscriptionsResponse();
            const subscriptions = [];
            for (const pubsub of Object.keys(this.pubSubSubscriptions)) {
                for (const topic of Object.keys(this.pubSubSubscriptions[pubsub])) {
                    const topicSubscription = new appcallback_pb_1.TopicSubscription();
                    topicSubscription.setPubsubName(pubsub);
                    topicSubscription.setTopic(topic);
                    // Dapr routes
                    const daprConfig = this.pubSubSubscriptions[pubsub][topic].dapr;
                    if (daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.deadLetterTopic) {
                        topicSubscription.setDeadLetterTopic(daprConfig.deadLetterTopic);
                    }
                    if (daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.bulkSubscribe) {
                        const bulkSubscribe = new appcallback_pb_1.BulkSubscribeConfig();
                        bulkSubscribe.setEnabled(daprConfig.bulkSubscribe.enabled);
                        if ((_a = daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.bulkSubscribe) === null || _a === void 0 ? void 0 : _a.maxMessagesCount) {
                            bulkSubscribe.setMaxMessagesCount(daprConfig.bulkSubscribe.maxMessagesCount);
                        }
                        if ((_b = daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.bulkSubscribe) === null || _b === void 0 ? void 0 : _b.maxAwaitDurationMs) {
                            bulkSubscribe.setMaxAwaitDurationMs(daprConfig.bulkSubscribe.maxAwaitDurationMs);
                        }
                        topicSubscription.setBulkSubscribe(bulkSubscribe);
                    }
                    if (daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.metadata) {
                        for (const [mKey, mValue] of Object.entries(daprConfig.metadata)) {
                            topicSubscription.getMetadataMap().set(mKey, mValue);
                        }
                    }
                    if (daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.routes) {
                        const routes = new appcallback_pb_1.TopicRoutes();
                        if ((_c = daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.routes) === null || _c === void 0 ? void 0 : _c.default) {
                            routes.setDefault((_d = daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.routes) === null || _d === void 0 ? void 0 : _d.default);
                        }
                        if ((_e = daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.routes) === null || _e === void 0 ? void 0 : _e.rules) {
                            for (const ruleItem of daprConfig.routes.rules) {
                                const rule = new appcallback_pb_1.TopicRule();
                                rule.setMatch(ruleItem.match);
                                rule.setPath(ruleItem.path);
                                routes.addRules(rule);
                            }
                        }
                        topicSubscription.setRoutes(routes);
                    }
                    else {
                        const routes = new appcallback_pb_1.TopicRoutes();
                        routes.setDefault((daprConfig === null || daprConfig === void 0 ? void 0 : daprConfig.route) || this.PUBSUB_DEFAULT_ROUTE_NAME);
                        topicSubscription.setRoutes(routes);
                    }
                    subscriptions.push(topicSubscription);
                }
            }
            res.setSubscriptionsList(subscriptions);
            return callback(null, res);
        });
    }
    // @todo: WIP
    listInputBindings(call, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = new appcallback_pb_1.ListInputBindingsResponse();
            res.setBindingsList(Object.keys(this.handlersBindings));
            return callback(null, res);
        });
    }
}
exports.default = GRPCServerImpl;
